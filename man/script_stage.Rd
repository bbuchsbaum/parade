% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/script_stage.R
\name{script_stage}
\alias{script_stage}
\title{Add a script-based stage to a parade flow}
\usage{
script_stage(
  fl,
  id,
  script,
  produces,
  needs = character(),
  engine = c("source", "system"),
  interpreter = NULL,
  prefix = TRUE,
  skip_when = NULL,
  ...
)
}
\arguments{
\item{fl}{A \code{parade_flow} object}

\item{id}{Unique stage identifier (character)}

\item{script}{Path to the script file (R, Python, bash, etc.)}

\item{produces}{Character vector of output declarations. Two forms:
\itemize{
\item \strong{Templates} (contain glue braces): glue-style path templates
resolved per grid row. Can be named or unnamed (unnamed single
defaults to \code{"output"}).
\item \strong{Names only} (no braces): output names only. The script must
call \code{\link[=script_returns]{script_returns()}} to declare actual paths.
}}

\item{needs}{Character vector of upstream stage IDs this stage depends on.
For the \code{source} engine, upstream outputs are injected into the script
environment as \verb{\{stage\}.\{field\}} variables.}

\item{engine}{Execution engine: \code{"source"} (default, uses \code{\link[base:source]{base::source()}})
or \code{"system"} (uses \code{\link[base:system2]{base::system2()}}).}

\item{interpreter}{For \code{engine = "system"}, the interpreter command.
If \code{NULL}, guessed from the script file extension.}

\item{prefix}{Whether to prefix output columns with stage ID (default \code{TRUE}).}

\item{skip_when}{Optional function (or formula) that receives the row's
variables (grid columns, upstream outputs, constants). If it returns
\code{TRUE}, the stage is skipped for that row and output columns are filled
with \code{NA}. Useful for avoiding redundant work when the same outputs
are shared across multiple grid rows.}

\item{...}{Additional constant arguments passed through to the stage.}
}
\value{
The input flow with the new script stage appended.
}
\description{
Wraps an external script as a first-class pipeline stage with declarative
output file templates and automatic parameter wiring. The script is expected
to write its output files; \code{script_stage()} verifies they exist and returns
file reference tibbles compatible with \code{\link[=artifact]{artifact()}} / \code{\link[=file_ref]{file_ref()}}.
}
\section{Two modes for \code{produces}}{


\strong{Template mode} — values contain glue placeholders (curly braces).
\code{script_stage()} resolves paths, injects them as variables
(\code{output_path}, \verb{<name>_path}), and verifies the files after the
script finishes:

\code{produces = c(model = "results/\\{subject\\}/model.rds")}

\strong{Manifest mode} — values are plain output names (no braces).
The script decides where to write and calls \code{\link[=script_returns]{script_returns()}} to
declare the paths. \code{script_stage()} reads the manifest and verifies:

\code{produces = c("model", "metrics")}
}

\section{Portable scripts with \code{get_arg()}}{


Scripts can use \code{\link[=get_arg]{get_arg()}} to read parameters. It works transparently
with both the \code{source} and \code{system} engines:

\if{html}{\out{<div class="sourceCode">}}\preformatted{x   <- get_arg("x")
out <- get_arg("output_path")
}\if{html}{\out{</div>}}
}

\examples{
\dontrun{
# Template mode: caller declares paths
flow(grid) |>
  script_stage("fit",
    script = "scripts/fit_model.R",
    produces = "results/{subject}/model.rds"
  )

# Template mode: multiple named outputs
flow(grid) |>
  script_stage("fit",
    script = "scripts/fit_model.R",
    produces = c(
      model   = "results/{subject}/model.rds",
      metrics = "results/{subject}/metrics.csv"
    )
  )

# Manifest mode: script declares paths via script_returns()
flow(grid) |>
  script_stage("fit",
    script = "scripts/fit_model.R",
    produces = c("model", "metrics")
  )

# System engine
flow(grid) |>
  script_stage("preproc",
    script = "scripts/preprocess.py",
    engine = "system",
    produces = "output/{subject}.nii.gz"
  )
}
}
