---
title: 'Quickstart: Build and Run a Flow'
output: rmarkdown::html_vignette
vignette: |
  %\VignetteIndexEntry{0. Quickstart: Build and Run a Flow} %\VignetteEngine{knitr::rmarkdown} %\VignetteEncoding{UTF-8}
params:
  family: red
css: albers.css
resource_files:
- albers.css
- albers.js
includes:
  in_header: |-
    <script src="albers.js"></script>
    <script>document.addEventListener('DOMContentLoaded',function(){document.body.classList.add('palette-red');});</script>

---

This quickstart walks you through a minimal Parade pipeline you can run
on your laptop. It uses local futures and small inputs to finish fast.

HPC note (optional)
-------------------

On clusters, you typically want `registry://` and `artifacts://` to live on
**shared scratch** (not `SLURM_TMPDIR`, which is usually node-local). Two common
ways to get set up:

```r
library(parade)

# One-command helper (recommended on clusters)
parade_init_hpc(persist = TRUE)
```

If you have a fixed allocation (e.g., **10 nodes Ã— 196 cores**), once you have a
flow `fl` you can set up distribution with a single helper and keep the DAG
code unchanged:

```r
fl <- fl |>
  distribute(dist_slurm_allocation(
    nodes = 10,
    cores_per_node = 196,
    within = "multicore",
    # Optional: oversubscribe to reduce stragglers for variable task durations
    target_jobs = 20
  ))
```

Or a minimal non-persistent setup:

```r
paths_init(profile = "hpc", create = TRUE)
parade_doctor()

# Copy/paste these into your SLURM template preamble if you want the same paths
cat(paste(paths_export(), collapse = "\n"))
```

1) Install and load
-------------------

```r
# install.packages("parade")  # CRAN or dev version if needed
library(parade)
```

2) Define a grid and a stage
----------------------------

```r
grid <- data.frame(x = 1:6, group = rep(LETTERS[1:3], each = 2))

fl <- flow(grid) |>
  stage(
    id = "calc",
    fn = function(x) x^2,
    schema = returns(result = dbl())
  )
```

3) Choose distribution
----------------------

```r
# Local parallelism by logical group (A/B/C)
fl <- fl |> distribute(dist_local(by = "group"))
```

4) Submit, await, and collect
-----------------------------

```r
d <- submit(fl)
deferred_await(d, timeout = 30)  # finite timeout for safety
out <- deferred_collect(d)
out
```

You should see a tibble with the original grid plus the `calc.result` column.

5) Add a sink (optional)
------------------------

```r
# Write results to a temp sink; switch to artifacts:// in real projects
fl2 <- flow(grid) |>
  stage(
    "calc", function(x) x^2,
    schema = returns(result = dbl()),
    sink = sink_temp(prefix = "quickstart")
  ) |>
  distribute(dist_local(by = "group"))

d2 <- submit(fl2)
deferred_await(d2, timeout = 30)
deferred_collect(d2)
```

Deepen your understanding
----------------

- Overview: concepts, distribution backends, sinks, and ergonomics
  - website: [Overview](articles/parade-overview.html)
  - R help: `vignette("parade-overview")`
- Unified API: submit functions/scripts and work with jobsets
  - website: [Unified API](articles/parade-unified-api.html)
  - R help: `vignette("parade-unified-api")`
- Sinks & Artifacts: formats, manifests, and best practices
  - website: [Sinks & Artifacts](articles/parade-sinks.html)
  - R help: `vignette("parade-sinks")`

See also: Path management and project setup in
[Smart Path Management](articles/parade-paths.html) (`vignette("parade-paths")`).
