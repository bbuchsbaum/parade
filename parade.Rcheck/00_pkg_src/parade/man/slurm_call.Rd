% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slurm_call.R
\name{slurm_call}
\alias{slurm_call}
\title{Submit an R function to SLURM}
\usage{
slurm_call(
  .f,
  ...,
  name = NULL,
  name_by = NULL,
  packages = character(),
  resources = NULL,
  template = NULL,
  registry_dir = NULL,
  env = character(),
  lib_paths = .libPaths(),
  rscript = file.path(R.home("bin"), "Rscript"),
  write_result = NULL,
  engine = c("slurm", "local"),
  .as_jobset = FALSE,
  .error_policy = NULL
)
}
\arguments{
\item{.f}{Function to execute on SLURM}

\item{...}{Arguments to pass to the function}

\item{name}{Optional job name (defaults to "slurm-call")}

\item{name_by}{Function or string for dynamic job naming. Can be "stem", "index",
"digest", or a function that takes the arguments and returns a string}

\item{packages}{Character vector of packages to load on the compute node}

\item{resources}{Named list of SLURM resource specifications}

\item{template}{Path to SLURM template file (uses default if NULL)}

\item{registry_dir}{Directory for batchtools registry (auto-generated if NULL)}

\item{env}{Named character vector of environment variables to set}

\item{lib_paths}{Character vector of library paths to use}

\item{rscript}{Path to Rscript executable}

\item{write_result}{Optional path to save function result (e.g., "artifacts://result.rds")}

\item{engine}{Execution engine: "slurm" (default) or "local" for debugging}

\item{.as_jobset}{Logical indicating whether to return a single-element jobset
instead of a bare job object. Defaults to FALSE for backward compatibility.}

\item{.error_policy}{Error handling policy from \code{on_error()}. Specifies how
to handle job failures, including retry logic and backoff strategies.}
}
\value{
A \code{parade_script_job} object for monitoring the job, or a
\code{parade_jobset} containing the job if \code{.as_jobset = TRUE}. If \code{write_result}
is specified, the job object will include a \code{result_path} attribute with
the resolved path where the result will be saved.
}
\description{
Submits an R function as a SLURM job by serializing the function and its
arguments, then executing them on the compute node. This provides an
ergonomic interface for running functions on SLURM without creating
explicit script files.
}
\details{
The function works by:
\enumerate{
\item Serializing the function and arguments to RDS files
\item Creating a small runner script that loads and executes them
\item Submitting the runner script via \code{submit_slurm()}
}

The function and its arguments are serialized using \code{saveRDS()}, which will
include the function's closure environment. Be aware that large objects
captured in the closure can significantly increase serialization size.

Packages specified in the \code{packages} argument will be loaded on the compute
node before executing the function. If your function depends on packages,
either specify them here or call \code{library()} within the function itself.
}
\examples{
# Local execution example (no SLURM required)
local_job <- slurm_call(
  function(x) x^2,
  x = 10,
  engine = "local"
)
# Returns result immediately
local_job$result

\donttest{
# Note: The following examples require a SLURM cluster environment
# Simple function submission
job <- slurm_call(
  function(x) x^2,
  x = 10,
  name = "square-10"
)

# With packages and result saving
job <- slurm_call(
  function(n) {
    matrix(rnorm(n * n), nrow = n)
  },
  n = 1000,
  packages = c("stats"),
  write_result = "artifacts://random_matrix.rds",
  resources = list(mem = "8G", time = "10min")
)

# Monitor the job
script_tail(job)
script_await(job)

# Load saved result
if (!is.null(job$result_path)) {
  result <- readRDS(job$result_path)
}
}

}
\seealso{
\code{\link{submit_slurm}} for submitting script files,
\code{\link{script_status}} for monitoring job status,
\code{\link{script_await}} for waiting for completion
}
